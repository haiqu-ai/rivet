<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>qml_transpiler.topological_compression API documentation</title>
<meta name="description" content="Topological Compression selects topologically most important qubits of a backend
to produce limited coupling map - to decrease transpilation and …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>qml_transpiler.topological_compression</code></h1>
</header>
<section id="section-intro">
<p>Topological Compression selects topologically most important qubits of a backend
to produce limited coupling map - to decrease transpilation and simulation time.</p>
<p>We use flexible measure of node importance - that includes “closeness centrality”
for every node in backend topology graph.</p>
<p>Closeness centrality is efficiently calculated using “rustworkx” graph library function:</p>
<p><a href="https://qiskit.org/ecosystem/rustworkx/dev/apiref/rustworkx.closeness_centrality.html">https://qiskit.org/ecosystem/rustworkx/dev/apiref/rustworkx.closeness_centrality.html</a></p>
<p>Flexible measure of node importance can be expanded with other metrics -
for example, neighbors counts or qubit noise levels.</p>
<p>Once importances are calculated - we traverse topology graph using A-star search -
starting from the most important node.</p>
<p>Traversed nodes are added to limited qubit list - which forms a connected subgraph.</p>
<p>Discovered subgraph can be used to limit backend topology - and save time
of further transpilation and simulation.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Topological Compression selects topologically most important qubits of a backend
to produce limited coupling map - to decrease transpilation and simulation time.

We use flexible measure of node importance - that includes “closeness centrality”
for every node in backend topology graph.

Closeness centrality is efficiently calculated using “rustworkx” graph library function:

https://qiskit.org/ecosystem/rustworkx/dev/apiref/rustworkx.closeness_centrality.html

Flexible measure of node importance can be expanded with other metrics -
for example, neighbors counts or qubit noise levels.

Once importances are calculated - we traverse topology graph using A-star search -
starting from the most important node.

Traversed nodes are added to limited qubit list - which forms a connected subgraph.

Discovered subgraph can be used to limit backend topology - and save time
of further transpilation and simulation.
&#34;&#34;&#34;

from rustworkx import closeness_centrality

from qiskit.transpiler import CouplingMap

from qml_transpiler.transpiler import transpile


def get_sorting_key(node):

    &#34;&#34;&#34;
    Specify the sorting key for a node in a coupling graph.

    Args:
        node: A node of a coupling graph.

    Returns:
        importance: The importance value used for sorting the nodes.
    &#34;&#34;&#34;

    node_index, importance = node

    return importance


def get_used_qubit_indices(circuit):

    &#34;&#34;&#34;
    Retrieves the indices of the qubits used in the given quantum circuit.

    Parameters:
    - circuit (QuantumCircuit): The quantum circuit for which to determine the used qubit indices.

    Returns:
    list of int: The indices of the qubits used in the circuit.

    Example:
    &gt;&gt;&gt; from qiskit import QuantumCircuit
    &gt;&gt;&gt; circuit = QuantumCircuit(3)
    &gt;&gt;&gt; circuit.h(0)
    &gt;&gt;&gt; circuit.cx(0, 2)
    &gt;&gt;&gt; used_qubit_indices = get_used_qubit_indices(circuit)
    &gt;&gt;&gt; print(used_qubit_indices)
    [0, 2]
    &#34;&#34;&#34;

    used_qubits = set()

    for instruction in circuit.data:
        for qubit in instruction.qubits:
            used_qubits.add(qubit)

    used_qubit_indices = [circuit.find_bit(qubit).index
                          for qubit in used_qubits]

    return used_qubit_indices


def get_limited_coupling_list(coupling_list, node_indices=None, max_nodes_count=None):

    &#34;&#34;&#34;
    Retrieves a limited coupling list based on node importances and a maximum number of nodes.

    Parameters:
    - coupling_list (list of Iterables): A list of edges representing the coupling between nodes.
    - node_indices (list or None): Indices of nodes to consider. If None, all nodes are considered.
    - max_nodes_count (int or None): Maximum number of nodes to include in the limited coupling list.
                                     If None, the total number of nodes in the original coupling map is used.

    Returns:
    list of lists: A limited coupling list containing edges connected to the most important nodes.

    Note:
    The importance of a node is determined by its closeness centrality in the coupling map graph.

    Algorithm Overview:
    1. Construct a graph from the given coupling list.
    2. Calculate closeness centrality for each node in the graph.
    3. Select nodes based on importance and limit the graph to these nodes.
    4. Traverse the graph to select a specified number of nodes with the highest importance.
    5. Generate a limited coupling list based on the selected nodes.

    Example:
    &gt;&gt;&gt; coupling_list = [(0, 1), (1, 2), (2, 3), (3, 0)]
    &gt;&gt;&gt; limited_list = get_limited_coupling_list(coupling_list, max_nodes_count=3)
    &gt;&gt;&gt; print(limited_list)
    [[0, 1], [1, 2], [2, 0]]
    &#34;&#34;&#34;

    # Topology

    coupling_map = CouplingMap(couplinglist=coupling_list)

    graph = coupling_map.graph.copy()

    if max_nodes_count is None:

        max_nodes_count = coupling_map.size()

    if node_indices is None:

        node_indices = list(graph.node_indices())

    # Node Importances

    importances = closeness_centrality(graph)

    # Node Formation

    for node_index in node_indices:

        importance = importances[node_index]

        graph[node_index] = (node_index, importance)

    # Topology Limitation

    for node_index in graph.node_indices():

        if node_index not in node_indices:

            graph.remove_node(node_index)

    # Graph Traversal

    selected_nodes = []

    candidates = {max(graph.nodes(), key=get_sorting_key)}

    while len(selected_nodes) &lt; max_nodes_count and candidates:

        new_node = max(candidates, key=get_sorting_key)

        candidates.remove(new_node)

        node_index, importance = new_node

        neighbours_indices = graph.neighbors(node_index)

        new_candidates = {graph[node_index] for node_index in neighbours_indices
                          if graph[node_index] not in selected_nodes}

        candidates.update(new_candidates)

        selected_nodes.append(new_node)

    # Selected Indices

    selected_indices, *_ = zip(*selected_nodes)

    limited_coupling_list = [list(edge) for edge in coupling_list
                             if all(index in selected_indices
                                    for index in edge)]

    return limited_coupling_list


def transpile_and_compress(circuit, backend, *arguments, **key_arguments):

    &#34;&#34;&#34;
    Transpiles the input quantum circuit, compresses it by considering the coupling map of the backend,
    and returns the compressed circuit.

    Parameters:
    - circuit (QuantumCircuit): The input quantum circuit to be transpiled and compressed.
    - backend (BaseBackend): The backend to use for transpilation and the associated coupling map for compression.
    - *arguments: Additional positional arguments to pass to the transpile function.
    - **key_arguments: Additional keyword arguments to pass to the transpile function.

    Returns:
    QuantumCircuit: The transpiled and compressed quantum circuit.

    Note:
    The compression involves considering the coupling map of the provided backend and adding unused qubits
    to the coupling map to avoid error-prone situations. Ancillas are also added to the layout to ensure
    correct transpilation.
    &#34;&#34;&#34;

    # First Transpilation

    transpiled_circuit = transpile(
        circuit,
        backend=backend,
        *arguments, **key_arguments)

    # Coupling List

    coupling_list = backend.configuration().coupling_map

    if coupling_list is None:

        UserWarning(&#34;Provided Backend has no topology - no compression performed&#34;)

        return transpiled_circuit

    # Node Indices

    node_indices = get_used_qubit_indices(transpiled_circuit)

    # Limited Coupling List

    limited_coupling_list = get_limited_coupling_list(
        coupling_list,
        node_indices=node_indices,
        max_nodes_count=circuit.num_qubits)

    # Add Ancillas to Coupling Map

    all_qubits = {qubit for pair in coupling_list for qubit in pair}

    used_qubits = {qubit for pair in limited_coupling_list for qubit in pair}

    unused_qubits = all_qubits - used_qubits

    unused_qubit_pairs = [[qubit, qubit] for qubit in unused_qubits]

    compressed_coupling_list = limited_coupling_list + unused_qubit_pairs

    # Second Transpilation

    compressed_circuit = transpile(
        circuit,
        backend=backend,
        coupling_map=compressed_coupling_list,
        *arguments, **key_arguments)

    # Add Ancillas to Layout

    layout = compressed_circuit.layout.final_layout

    for qubit_index, qubit in enumerate(compressed_circuit.qubits):

        if qubit_index not in layout:

            layout[qubit_index] = qubit

    return compressed_circuit</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="qml_transpiler.topological_compression.get_limited_coupling_list"><code class="name flex">
<span>def <span class="ident">get_limited_coupling_list</span></span>(<span>coupling_list, node_indices=None, max_nodes_count=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a limited coupling list based on node importances and a maximum number of nodes.</p>
<p>Parameters:
- coupling_list (list of Iterables): A list of edges representing the coupling between nodes.
- node_indices (list or None): Indices of nodes to consider. If None, all nodes are considered.
- max_nodes_count (int or None): Maximum number of nodes to include in the limited coupling list.
If None, the total number of nodes in the original coupling map is used.</p>
<p>Returns:
list of lists: A limited coupling list containing edges connected to the most important nodes.</p>
<p>Note:
The importance of a node is determined by its closeness centrality in the coupling map graph.</p>
<p>Algorithm Overview:
1. Construct a graph from the given coupling list.
2. Calculate closeness centrality for each node in the graph.
3. Select nodes based on importance and limit the graph to these nodes.
4. Traverse the graph to select a specified number of nodes with the highest importance.
5. Generate a limited coupling list based on the selected nodes.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; coupling_list = [(0, 1), (1, 2), (2, 3), (3, 0)]
&gt;&gt;&gt; limited_list = get_limited_coupling_list(coupling_list, max_nodes_count=3)
&gt;&gt;&gt; print(limited_list)
[[0, 1], [1, 2], [2, 0]]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_limited_coupling_list(coupling_list, node_indices=None, max_nodes_count=None):

    &#34;&#34;&#34;
    Retrieves a limited coupling list based on node importances and a maximum number of nodes.

    Parameters:
    - coupling_list (list of Iterables): A list of edges representing the coupling between nodes.
    - node_indices (list or None): Indices of nodes to consider. If None, all nodes are considered.
    - max_nodes_count (int or None): Maximum number of nodes to include in the limited coupling list.
                                     If None, the total number of nodes in the original coupling map is used.

    Returns:
    list of lists: A limited coupling list containing edges connected to the most important nodes.

    Note:
    The importance of a node is determined by its closeness centrality in the coupling map graph.

    Algorithm Overview:
    1. Construct a graph from the given coupling list.
    2. Calculate closeness centrality for each node in the graph.
    3. Select nodes based on importance and limit the graph to these nodes.
    4. Traverse the graph to select a specified number of nodes with the highest importance.
    5. Generate a limited coupling list based on the selected nodes.

    Example:
    &gt;&gt;&gt; coupling_list = [(0, 1), (1, 2), (2, 3), (3, 0)]
    &gt;&gt;&gt; limited_list = get_limited_coupling_list(coupling_list, max_nodes_count=3)
    &gt;&gt;&gt; print(limited_list)
    [[0, 1], [1, 2], [2, 0]]
    &#34;&#34;&#34;

    # Topology

    coupling_map = CouplingMap(couplinglist=coupling_list)

    graph = coupling_map.graph.copy()

    if max_nodes_count is None:

        max_nodes_count = coupling_map.size()

    if node_indices is None:

        node_indices = list(graph.node_indices())

    # Node Importances

    importances = closeness_centrality(graph)

    # Node Formation

    for node_index in node_indices:

        importance = importances[node_index]

        graph[node_index] = (node_index, importance)

    # Topology Limitation

    for node_index in graph.node_indices():

        if node_index not in node_indices:

            graph.remove_node(node_index)

    # Graph Traversal

    selected_nodes = []

    candidates = {max(graph.nodes(), key=get_sorting_key)}

    while len(selected_nodes) &lt; max_nodes_count and candidates:

        new_node = max(candidates, key=get_sorting_key)

        candidates.remove(new_node)

        node_index, importance = new_node

        neighbours_indices = graph.neighbors(node_index)

        new_candidates = {graph[node_index] for node_index in neighbours_indices
                          if graph[node_index] not in selected_nodes}

        candidates.update(new_candidates)

        selected_nodes.append(new_node)

    # Selected Indices

    selected_indices, *_ = zip(*selected_nodes)

    limited_coupling_list = [list(edge) for edge in coupling_list
                             if all(index in selected_indices
                                    for index in edge)]

    return limited_coupling_list</code></pre>
</details>
</dd>
<dt id="qml_transpiler.topological_compression.get_sorting_key"><code class="name flex">
<span>def <span class="ident">get_sorting_key</span></span>(<span>node)</span>
</code></dt>
<dd>
<div class="desc"><p>Specify the sorting key for a node in a coupling graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>node</code></strong></dt>
<dd>A node of a coupling graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>importance</code></dt>
<dd>The importance value used for sorting the nodes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sorting_key(node):

    &#34;&#34;&#34;
    Specify the sorting key for a node in a coupling graph.

    Args:
        node: A node of a coupling graph.

    Returns:
        importance: The importance value used for sorting the nodes.
    &#34;&#34;&#34;

    node_index, importance = node

    return importance</code></pre>
</details>
</dd>
<dt id="qml_transpiler.topological_compression.get_used_qubit_indices"><code class="name flex">
<span>def <span class="ident">get_used_qubit_indices</span></span>(<span>circuit)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the indices of the qubits used in the given quantum circuit.</p>
<p>Parameters:
- circuit (QuantumCircuit): The quantum circuit for which to determine the used qubit indices.</p>
<p>Returns:
list of int: The indices of the qubits used in the circuit.</p>
<p>Example:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from qiskit import QuantumCircuit
&gt;&gt;&gt; circuit = QuantumCircuit(3)
&gt;&gt;&gt; circuit.h(0)
&gt;&gt;&gt; circuit.cx(0, 2)
&gt;&gt;&gt; used_qubit_indices = get_used_qubit_indices(circuit)
&gt;&gt;&gt; print(used_qubit_indices)
[0, 2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_used_qubit_indices(circuit):

    &#34;&#34;&#34;
    Retrieves the indices of the qubits used in the given quantum circuit.

    Parameters:
    - circuit (QuantumCircuit): The quantum circuit for which to determine the used qubit indices.

    Returns:
    list of int: The indices of the qubits used in the circuit.

    Example:
    &gt;&gt;&gt; from qiskit import QuantumCircuit
    &gt;&gt;&gt; circuit = QuantumCircuit(3)
    &gt;&gt;&gt; circuit.h(0)
    &gt;&gt;&gt; circuit.cx(0, 2)
    &gt;&gt;&gt; used_qubit_indices = get_used_qubit_indices(circuit)
    &gt;&gt;&gt; print(used_qubit_indices)
    [0, 2]
    &#34;&#34;&#34;

    used_qubits = set()

    for instruction in circuit.data:
        for qubit in instruction.qubits:
            used_qubits.add(qubit)

    used_qubit_indices = [circuit.find_bit(qubit).index
                          for qubit in used_qubits]

    return used_qubit_indices</code></pre>
</details>
</dd>
<dt id="qml_transpiler.topological_compression.transpile_and_compress"><code class="name flex">
<span>def <span class="ident">transpile_and_compress</span></span>(<span>circuit, backend, *arguments, **key_arguments)</span>
</code></dt>
<dd>
<div class="desc"><p>Transpiles the input quantum circuit, compresses it by considering the coupling map of the backend,
and returns the compressed circuit.</p>
<p>Parameters:
- circuit (QuantumCircuit): The input quantum circuit to be transpiled and compressed.
- backend (BaseBackend): The backend to use for transpilation and the associated coupling map for compression.
- <em>arguments: Additional positional arguments to pass to the transpile function.
- </em>*key_arguments: Additional keyword arguments to pass to the transpile function.</p>
<p>Returns:
QuantumCircuit: The transpiled and compressed quantum circuit.</p>
<p>Note:
The compression involves considering the coupling map of the provided backend and adding unused qubits
to the coupling map to avoid error-prone situations. Ancillas are also added to the layout to ensure
correct transpilation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transpile_and_compress(circuit, backend, *arguments, **key_arguments):

    &#34;&#34;&#34;
    Transpiles the input quantum circuit, compresses it by considering the coupling map of the backend,
    and returns the compressed circuit.

    Parameters:
    - circuit (QuantumCircuit): The input quantum circuit to be transpiled and compressed.
    - backend (BaseBackend): The backend to use for transpilation and the associated coupling map for compression.
    - *arguments: Additional positional arguments to pass to the transpile function.
    - **key_arguments: Additional keyword arguments to pass to the transpile function.

    Returns:
    QuantumCircuit: The transpiled and compressed quantum circuit.

    Note:
    The compression involves considering the coupling map of the provided backend and adding unused qubits
    to the coupling map to avoid error-prone situations. Ancillas are also added to the layout to ensure
    correct transpilation.
    &#34;&#34;&#34;

    # First Transpilation

    transpiled_circuit = transpile(
        circuit,
        backend=backend,
        *arguments, **key_arguments)

    # Coupling List

    coupling_list = backend.configuration().coupling_map

    if coupling_list is None:

        UserWarning(&#34;Provided Backend has no topology - no compression performed&#34;)

        return transpiled_circuit

    # Node Indices

    node_indices = get_used_qubit_indices(transpiled_circuit)

    # Limited Coupling List

    limited_coupling_list = get_limited_coupling_list(
        coupling_list,
        node_indices=node_indices,
        max_nodes_count=circuit.num_qubits)

    # Add Ancillas to Coupling Map

    all_qubits = {qubit for pair in coupling_list for qubit in pair}

    used_qubits = {qubit for pair in limited_coupling_list for qubit in pair}

    unused_qubits = all_qubits - used_qubits

    unused_qubit_pairs = [[qubit, qubit] for qubit in unused_qubits]

    compressed_coupling_list = limited_coupling_list + unused_qubit_pairs

    # Second Transpilation

    compressed_circuit = transpile(
        circuit,
        backend=backend,
        coupling_map=compressed_coupling_list,
        *arguments, **key_arguments)

    # Add Ancillas to Layout

    layout = compressed_circuit.layout.final_layout

    for qubit_index, qubit in enumerate(compressed_circuit.qubits):

        if qubit_index not in layout:

            layout[qubit_index] = qubit

    return compressed_circuit</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="qml_transpiler" href="index.html">qml_transpiler</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="qml_transpiler.topological_compression.get_limited_coupling_list" href="#qml_transpiler.topological_compression.get_limited_coupling_list">get_limited_coupling_list</a></code></li>
<li><code><a title="qml_transpiler.topological_compression.get_sorting_key" href="#qml_transpiler.topological_compression.get_sorting_key">get_sorting_key</a></code></li>
<li><code><a title="qml_transpiler.topological_compression.get_used_qubit_indices" href="#qml_transpiler.topological_compression.get_used_qubit_indices">get_used_qubit_indices</a></code></li>
<li><code><a title="qml_transpiler.topological_compression.transpile_and_compress" href="#qml_transpiler.topological_compression.transpile_and_compress">transpile_and_compress</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>